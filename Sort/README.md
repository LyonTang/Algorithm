# Sort 排序算法（升序）

## 冒泡排序
写在最前面却是我实际测试中最烂的算法。

数据总与相邻的数比较，遇到较大数据冒泡（前后位置交换），第`n`次冒泡只需考虑前`length-n+1`个数。

有两个优化选项：第`n`次没有发生交换，那么说明数据已完成排序；第`n`次最后发生交换的位置之后的数据是有序的。
优化只是让自己思路更开阔，这个算法在数据增加时，耗时起飞。

## 选择排序
在外层的`length-1`次循环中，不断找出前`n`个数中最大值，交换到第`n`位。

## 插入排序
只需要考虑当前数据与其前面的数据大小比较，直到即将遇到小于等于当前数据时，插入该位置。

## 希尔排序
希尔排序是对插入排序的优化，将一维数组转换成二维数组的过程中使用插入排序提高数据整体有序性。[希尔排序](https://blog.csdn.net/weixin_40539125/article/details/100128421)

## 归并排序
归并是两个操作：递归排序，和并排序结果，不断的将序列二分，直到只有一个数据，合并分裂的的序列，需要一个中间数组暂存合并结果，每次都去左、右序列中最小值放入中间数组，合并结果必有序。

## 快速排序
快速排序是一个递归查找目标数据所在索引的算法，将数据分成大于基准值和小于基准值的两组，不断递归。它不保证两组数组有序，但保证了基准值的索引正确。

## 堆排序
根据数组`R`构造一个堆（完全二叉树）,对于节点`R[i]`,其子节点分别为`R[2i+1]`和`R[2i+2]`。然后交换顺序构造一个大根堆(`R[i] >= R[2i+1] && R[i] >= R[2i+2]`) ,最后交换`R[0]`和`R[last]`.

一开始算法在递归中不断全量构建大根树，数据稍微大一点就会出现StackOverflow异常，其实并不需要，只需要满足第一次初始化一颗大根树，就可以在交换后对0号节点重新做一次向下的大根调整就行

## Finally
- 递归算法对栈还是有要求的，数据量大时，容易触发栈溢出，以后有时间在看看怎么改吧